msgid ""
msgstr ""
"Project-Id-Version: Zed\n"
"POT-Creation-Date: 2025-12-22T17:48:26Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/languages/c.md:1
msgid "C"
msgstr ""

#: src/languages/c.md:3
msgid "C support is available natively in Zed."
msgstr ""

#: src/languages/c.md:5
msgid ""
"Tree-sitter: [tree-sitter/tree-sitter-c](https://github.com/tree-sitter/tree-"
"sitter-c)"
msgstr ""

#: src/languages/c.md:6
msgid "Language Server: [clangd/clangd](https://github.com/clangd/clangd)"
msgstr ""

#: src/languages/c.md:7
msgid ""
"Debug Adapter: [CodeLLDB](https://github.com/vadimcn) (primary), [GDB]"
"(https://sourceware.org/gdb/) (secondary, not available on Apple silicon)"
msgstr ""

#: src/languages/c.md:9
msgid "Clangd: Force detect as C"
msgstr ""

#: src/languages/c.md:11
msgid ""
"Clangd out of the box assumes mixed C++/C projects. If you have a C-only "
"project you may wish to instruct clangd to treat all files as C using the `-"
"xc` flag. To do this, create a `.clangd` file in the root of your project "
"with the following:"
msgstr ""

#: src/languages/c.md:14
msgid ""
"# yaml-language-server: $schema=https://json.schemastore.org/clangd.json\n"
"CompileFlags"
msgstr ""

#: src/languages/c.md:16
msgid "Add"
msgstr ""

#: src/languages/c.md:16
msgid "-xc"
msgstr ""

#: src/languages/c.md:19
msgid ""
"By default clang and gcc will recognize `*.C` and `*.H` (uppercase "
"extensions) as C++ and not C and so Zed too follows this convention. If you "
"are working with a C-only project (perhaps one with legacy uppercase pathing "
"like `FILENAME.C`) you can override this behavior by adding this to your "
"settings:"
msgstr ""

#: src/languages/c.md:23
msgid "\"file_types\""
msgstr ""

#: src/languages/c.md:24 src/languages/c.md:47
msgid "\"C\""
msgstr ""

#: src/languages/c.md:24
msgid "\"H\""
msgstr ""

#: src/languages/c.md:29
msgid "Formatting"
msgstr ""

#: src/languages/c.md:31
msgid ""
"By default Zed will use the `clangd` language server for formatting C code "
"like the `clang-format` CLI tool. To configure this you can add a `.clang-"
"format` file. For example:"
msgstr ""

#: src/languages/c.md:34
msgid ""
"# yaml-language-server: $schema=https://json.schemastore.org/clang-format-21."
"x.json\n"
msgstr ""

#: src/languages/c.md:35
msgid "BasedOnStyle"
msgstr ""

#: src/languages/c.md:36
msgid "GNU"
msgstr ""

#: src/languages/c.md:36
msgid "IndentWidth"
msgstr ""

#: src/languages/c.md:41
msgid ""
"See [Clang-Format Style Options](https://clang.llvm.org/docs/"
"ClangFormatStyleOptions.html) for a complete list of options."
msgstr ""

#: src/languages/c.md:43
msgid ""
"You can trigger formatting via <kbd class=\"keybinding\">cmd-shift-i|ctrl-"
"shift-i</kbd> or the `editor: format` action from the command palette or by "
"adding `format_on_save` to your Zed settings:"
msgstr ""

#: src/languages/c.md:46
msgid "\"languages\""
msgstr ""

#: src/languages/c.md:48
msgid "\"format_on_save\""
msgstr ""

#: src/languages/c.md:48
msgid "\"on\""
msgstr ""

#: src/languages/c.md:49
msgid "\"tab_size\""
msgstr ""

#: src/languages/c.md:54
msgid "Compile Commands"
msgstr ""

#: src/languages/c.md:56
msgid ""
"For some projects Clangd requires a `compile_commands.json` file to properly "
"analyze your project. This file contains the compilation database that tells "
"clangd how your project should be built."
msgstr ""

#: src/languages/c.md:58
msgid "CMake Compile Commands"
msgstr ""

#: src/languages/c.md:60
msgid ""
"With CMake, you can generate `compile_commands.json` automatically by adding "
"the following line to your `CMakeLists.txt`:"
msgstr ""

#: src/languages/c.md:66
msgid ""
"After building your project, CMake will generate the `compile_commands.json` "
"file in the build directory and clangd will automatically pick it up."
msgstr ""

#: src/languages/c.md:68
msgid "Debugging"
msgstr ""

#: src/languages/c.md:70
msgid ""
"You can use CodeLLDB or GDB to debug native binaries. (Make sure that your "
"build process passes `-g` to the C compiler, so that debug information is "
"included in the resulting binary.) See below for examples of debug "
"configurations that you can add to `.zed/debug.json`."
msgstr ""

#: src/languages/c.md:72
msgid ""
"[CodeLLDB configuration documentation](https://github.com/vadimcn/codelldb/"
"blob/master/MANUAL.md#starting-a-new-debug-session)"
msgstr ""

#: src/languages/c.md:73
msgid ""
"[GDB configuration documentation](https://sourceware.org/gdb/current/"
"onlinedocs/gdb.html/Debugger-Adapter-Protocol.html)"
msgstr ""

#: src/languages/c.md:75
msgid "Build and Debug Binary"
msgstr ""

#: src/languages/c.md:80
msgid "\"label\""
msgstr ""

#: src/languages/c.md:80
msgid "\"Debug native binary\""
msgstr ""

#: src/languages/c.md:81
msgid "\"build\""
msgstr ""

#: src/languages/c.md:82
msgid "\"command\""
msgstr ""

#: src/languages/c.md:82
msgid "\"make\""
msgstr ""

#: src/languages/c.md:83
msgid "\"args\""
msgstr ""

#: src/languages/c.md:83
msgid "\"-j8\""
msgstr ""

#: src/languages/c.md:84
msgid "\"cwd\""
msgstr ""

#: src/languages/c.md:84
msgid "\"$ZED_WORKTREE_ROOT\""
msgstr ""

#: src/languages/c.md:86
msgid "\"program\""
msgstr ""

#: src/languages/c.md:86
msgid "\"$ZED_WORKTREE_ROOT/build/prog\""
msgstr ""

#: src/languages/c.md:87
msgid "\"request\""
msgstr ""

#: src/languages/c.md:87
msgid "\"launch\""
msgstr ""

#: src/languages/c.md:88
msgid "\"adapter\""
msgstr ""

#: src/languages/c.md:88
msgid "\"CodeLLDB\""
msgstr ""
